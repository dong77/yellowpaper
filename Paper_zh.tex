% !TEX program = XeLaTeX
% !TEX encoding = UTF-8
\documentclass[UTF8,nofonts]{ctexart}
\setCJKmainfont[BoldFont=FandolSong-Bold.otf,ItalicFont=FandolKai-Regular.otf]{FandolSong-Regular.otf}
\setCJKsansfont[BoldFont=FandolHei-Bold.otf]{FandolHei-Regular.otf}
\setCJKmonofont{FandolFang-Regular.otf}

%\usepackage{tweaklist}
\usepackage{url}
\usepackage{cancel}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{subfig}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[a4paper,width=170mm,top=18mm,bottom=22mm,includeheadfoot]{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{verbatim}
\usepackage{caption}
\usepackage{natbib}
\usepackage{float}
\usepackage{pdflscape}
\usepackage{mathtools}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{afterpage}
\usepackage{tikz}

\newcommand{\hcancel}[1]{%
    \tikz[baseline=(tocancel.base)]{
        \node[inner sep=0pt,outer sep=0pt] (tocancel) {#1};
        \draw[black] (tocancel.south west) -- (tocancel.north east);
    }%
}%

\definecolor{lightyellow}{rgb}{1,0.98,0.9}
\definecolor{lightpink}{rgb}{1,0.94,0.95}

\newcommand{\firsthomesteadblock}{\ensuremath{N_H}}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\newcommand*\eg{e.g.\@\xspace}
\newcommand*\Eg{e.g.\@\xspace}
\newcommand*\ie{i.e.\@\xspace}
%\renewcommand{\itemhook}{\setlength{\topsep}{0pt}  \setlength{\itemsep}{0pt}\setlength{\leftmargin}{15pt}}

\title{Ethereum: A Secure Decentralised Generalised Transaction Ledger \\ {\smaller \textbf{Homestead revision}}}
\author{
    Dr. Gavin Wood\\
    Founder, Ethereum \& Ethcore\\
    gavin@ethcore.io
}

\begin{document}

%\pagecolor{lightyellow}
\pagecolor{lightpink}

\begin{abstract}
一些列的项目，特别是比特币，已经证明了区块链模式在结合了经密码保护的交易后的应用价值。每个这样项目都可以被视为建立在去中心化的，整体而言却构成单例的，计算资源上的简单应用。我们可以称区块链的模式为共享状态，支持交易的单例计算机。

以太坊用一种更通用的方式实现这种模式。而且它提供丰富的计算资源，每个资源都有不同的状态和操作代码，但能够通过消息传递框架与彼此交互。在本文我们探讨它的设计，实现问题，以及它带来的机遇和未来可能的挑战。
\end{abstract}

\setlength{\columnsep}{20pt}
\begin{multicols}{2}

\section{介绍}\label{sec:introduction}

With ubiquitous internet connections in most places of the world, global information transmission has become incredibly cheap. Technology-rooted movements like Bitcoin have demonstrated, through the power of the default, consensus mechanisms and voluntary respect of the social contract that it is possible to use the internet to make a decentralised value-transfer system, shared across the world and virtually free to use. This system can be said to be a very specialised version of a cryptographically secure, transaction-based state machine. Follow-up systems such as Namecoin adapted this original ``currency application'' of the technology into other applications albeit rather simplistic ones.

Ethereum is a project which attempts to build the generalised technology; technology on which all transaction-based state machine concepts may be built. Moreover it aims to provide to the end-developer a tightly integrated end-to-end system for building software on a hitherto unexplored compute paradigm in the mainstream: a trustful object messaging compute framework.

\subsection{Driving Factors} \label{ch:driving}

There are many goals of this project; one key goal is to facilitate transactions between consenting individuals who would otherwise have no means to trust one another. This may be due to geographical separation, interfacing difficulty, or perhaps the incompatibility, incompetence, unwillingness, expense, uncertainty, inconvenience or corruption of existing legal systems. By specifying a state-change system through a rich and unambiguous language, and furthermore architecting a system such that we can reasonably expect that an agreement will be thus enforced autonomously, we can provide a means to this end.

Dealings in this proposed system would have several attributes not often found in the real world. The incorruptibility of judgement, often difficult to find, comes naturally from a disinterested algorithmic interpreter. Transparency, or being able to see exactly how a state or judgement came about through the transaction log and rules or instructional codes, never happens perfectly in human-based systems since natural language is necessarily vague, information is often lacking, and plain old prejudices are difficult to shake.

Overall, I wish to provide a system such that users can be guaranteed that no matter with which other individuals, systems or organisations they interact, they can do so with absolute confidence in the possible outcomes and how those outcomes might come about.

\subsection{Previous Work} \label{ch:previous}

\cite{buterin2013ethereum} first proposed the kernel of this work in late November, 2013. Though now evolved in many ways, the key functionality of a block-chain with a Turing-complete language and an effectively unlimited inter-transaction storage capability remains unchanged.

Hashcash, introduced by \cite{back2002hashcash} (in a five-year retrospective), provided the first work into the usage of a cryptographic proof of computational expenditure as a means of transmitting a value signal over the Internet. Though not widely adopted, the work was later utilised and expanded upon by \cite{nakamoto2008bitcoin} in order to devise a cryptographically secure mechanism for coming to a decentralised social consensus over the order and contents of a series of cryptographically signed financial transactions. The fruits of this project, Bitcoin, provided a first glimpse into a decentralised transaction ledger.

Other projects built on Bitcoin's success; the alt-coins introduced numerous other currencies through alteration to the protocol. Some of the best known are Litecoin and Primecoin, discussed by \cite{sprankel2013technical}. Other projects sought to take the core value content mechanism of the protocol and repurpose it; \cite{aron2012bitcoin} discusses, for example, the Namecoin project which aims to provide a decentralised name-resolution system.

Other projects still aim to build upon the Bitcoin network itself, leveraging the large amount of value placed in the system and the vast amount of computation that goes into the consensus mechanism. The Mastercoin project, first proposed by \cite{mastercoin2013willett}, aims to build a richer protocol involving many additional high-level features on top of the Bitcoin protocol through utilisation of a number of auxiliary parts to the core protocol. The Coloured Coins project, proposed by \cite{colouredcoins2012rosenfeld}, takes a similar but more simplified strategy, embellishing the rules of a transaction in order to break the fungibility of Bitcoin's base currency and allow the creation and tracking of tokens through a special ``chroma-wallet''-protocol-aware piece of software.

Additional work has been done in the area with discarding the decentralisation foundation; Ripple, discussed by \cite{boutellier2014pirates}, has sought to create a ``federated'' system for currency exchange, effectively creating a new financial clearing system. It has demonstrated that high efficiency gains can be made if the decentralisation premise is discarded.

Early work on smart contracts has been done by \cite{szabo1997formalizing} and \cite{miller1997future}. Around the 1990s it became clear that algorithmic enforcement of agreements could become a significant force in human cooperation. Though no specific system was proposed to implement such a system, it was proposed that the future of law would be heavily affected by such systems. In this light, Ethereum may be seen as a general implementation of such a \textit{crypto-law} system.

%-------------------------------------
\section{区块链（Blockchain）模式} \label{ch:overview}

以太坊作为一个整体可被视为基于交易的状态机：我们从一个创世纪（genesis）状态开始，递增执行交易来改变状态机到某个最终状态。这个最终状态将被我们认定为以太坊世界的权威性``版本''。状态中包含的信息包括账户余额，声誉，信任安排，物理世界数据，终止，任何计算机可以表示的数据都可以。因此交易是两个状态间的一条合法的弧线；这里`合法`非常重要 -- 不合法的变更改变要远远多于合法的状态改变。 例如减少一个账户的余额但没有在其它账户中做等量余额增加就是不合法的状态变更。一个合法的状态需要经过一个交易。形式化表达为：

\begin{equation}
\boldsymbol{\sigma}_{t+1} \equiv \Upsilon(\boldsymbol{\sigma}_t, T)
\end{equation}

其中$\Upsilon$是以太坊状态转换函数。 在以太坊中，$\Upsilon$ 和$\boldsymbol{\sigma}$ 结合一起比任何现存的比较系统都更强大。$\Upsilon$ 允许模块进行任意计算，而 $\boldsymbol{\sigma}$ 允许模块存储交易间的任何状态。

多个交易被收集合并成一个区块（Block),多个区块通过基于密码学的散列值链接起来成为区块链，散列值也被用作块的引用。区块的作用类似与日志，用来记录一些列交易，前一个区块，以及最终状态的标识符（但不存储最终状态本身 --- 否者就太大了）。区块间穿插着节点\textit{挖矿}所需的激励。这种激励措施在状态转换函数中发生，其结果是给指定的账户增加余额。

挖矿是通过贡献算力（工作量）推举一系列交易（一个区块）战胜其它潜在的竞争区块的过程。挖矿依赖于一种密码学上安全的证明。这种证明被称为工作量证明（Proof-of-Work），我们会在 \ref{ch:pow} 章节做详细探讨。

我们在公式上进一步展开：
\begin{eqnarray}
\boldsymbol{\sigma}_{t+1} & \equiv & \Pi(\boldsymbol{\sigma}_t, B) \\
B & \equiv & (..., (T_0, T_1, ...) ) \\
\Pi(\boldsymbol{\sigma}, B) & \equiv & \Omega(B, \Upsilon(\Upsilon(\boldsymbol{\sigma}, T_0), T_1) ...)
\end{eqnarray}

其中 $\Omega$ 是确认区块终态的变更函数（它回馈指定的参与方）；$B$ 是当前区块，包含一些列交易和其它数据；$\Pi$ 是区块级的状态变更函数。

这就是区块链的基础模型，它不仅仅是以太坊，也是目前所有去中心化的，基于共识的交易系统的骨架。


\subsection{价值}

为了激励网络中的计算，以太坊需要有个公认的价值传递方式。为了解决这个问题，以太坊引入了一个内在的货币，以太（Ether），也被称作{\small ETH}，有时用英文字母 \DH{}表示。以太的最小单位，也是该货币整数值计数所用的单位，叫伟（Wei）。一个以太被定义为 $10^{18}$ 个伟。除此之外还有其它以子单位：

\par
\begin{center}
\begin{tabular}{rl}
\toprule
乘数 & 子单位名字 \\
\midrule
$10^0$ & 伟（Wei） \\
$10^{12}$ & 萨博（Szabo） \\
$10^{15}$ & 芬尼（Finney） \\
$10^{18}$ & 以太（Ether） \\
\bottomrule
\end{tabular}
\end{center}
\par


在本文中提到以太价值，货币，余额，付款的时候，我们默认都是以伟作为计数单位。

\subsection{哪个历史？}

既然系统是去中心化的，且任何参与方都有机会在前序区块的基础上生成一个新的区块，其结果就一定是个区块的树形结构。为了对区块链，也就是从根节点区块（创世纪区块）到某个叶节点区块（包含最新交易的区块）的路径，达成共识，就需要一个大家都认同的方案。如果网络节点对哪个路径才是`最好'的区块链存在分歧，就会发生\textit{fork} 。

这意味着在某个时间节点（区块）后，可能有多种系统状态共存：一些节点认为这个区块包含权威的交易，另一些节点认为那个区块包含权威的交易，这些区块可能包含根本不同或不兼容的交易。这种情况需要尽最大可能避免，否则造成的不确定性可能毁掉对整个系统的信心。

我们用来达成共识的方案是由\cite{cryptoeprint:2013:881}引入的GHOST协议的一个简化版。我们在\ref{ch:ghost}章节描述这个方案的流程。

%-------------------------------------

\section{约定}\label{ch:conventions}

对于正规符号，我使用一些列的印刷方面的约定，其中的一些是本文特有的：

两类高度结构化的，`顶级的'，状态值，用粗体小写希腊字母表示。这两类分别是世界状态，用$\boldsymbol{\sigma}$（或其变种）表示，和机器状态，用$\boldsymbol{\mu}$表示。

高度结构化值上的函数用大写希腊字母表示，比如以太坊状态转换函数用$\Upsilon$表示。

大多数函数用大写字母表示，比如一般的成本函数（cost function）用$C$表示。函数符号可以通过加下标来表示特定的变种，比如{\tiny SSTORE} 操作的成本函数用$C_\text{\tiny SSTORE}$表示。对于特定的及有可能是外部定义的函数，我可能用打字机字体表示，比如Keccak-256散列函数（SHA-3竞赛的获奖者）用$\texttt{KEC}$表示（通常被称为简单Keccak散列函数）。$\texttt{KEC512}$被称为Keccak 512散列函数。

元组（Tuple）一般用一个大写字母表示，比如$T$用来表示一个以太坊交易。可为该符号加下标来标识它的单个组成部分，比如$T_n$表示该交易的nonce。下标的格式标明其类型，比如大写的下标说明该元组有可通过下标标识的组成部分。

标量（Scalar）和固定大小的字节序列（或叫字节数组）用一个小写字母表示，比如本文中交易的nonce用$n$表示。有特殊意义的值可能用希腊字母表示，比如栈上某个操作所需的数据数目用$\delta$表示。

任意长度序列一般用一个粗体小写字母表示，比如消息调用的输出是个字节序列，它用$\mathbf{o}$表示。特别重要的值可能用一个粗体大写字母表示。

我们通篇假设标量都是正整数，因此属于$\mathbb{P}$集合。所有字节顺序列的集合为 $\mathbb{B}$，在附录\ref{app:rlp}中给出正式定义。有特别长度限制的字符序列集合用下标标识，因此所有长度为$32$ 的字节序列集合被称为$\mathbb{B}_{32}$，所有小于$2^{256}$ 的正整数集合被称为$\mathbb{P}_{256}$。其正式定义被放到\ref{ch:block}章节。

方括号用来索引和引用序列中的单个组件或子序列，比如 $\boldsymbol{\mu}_\mathbf{s}[0]$表示机器栈上的第一项。对于子序列，我们用省略号来指明区域，比如$\boldsymbol{\mu}_\mathbf{m}[0..31]$表示机器内存的前32项。

对于全局状态$\boldsymbol{\sigma}$，其本身是一组账户，账户本身又是元组，方括号用来表示单个账户。


当考虑现有值的各种变化的时候，我的原则是在定义的范围内，如果用占位符$\Box$ 表示某个未被更改的`输入'值，那么改变后和可用值就用$\Box'$表示，中间值用$\Box^*$,  $\Box^{**}$等表示。特别情况下，为了最大化可读性并且不会引入歧义的时候，我可能用字母或数字下标去标识中间值，尤其是那些需要特别关注的中间值。

在使用现有函数时，对于函数 $f$，我用函数$f^*$表示一个和原函数相似的，序列元素级别的映射函数。其正式定义被放到\ref{ch:block}章节。

另外我定义了一些有用的函数。其中一个常用的是 $\ell$，它返回一个序列的末项。


\begin{equation}
\ell(\mathbf{x}) \equiv \mathbf{x}[\lVert \mathbf{x} \rVert - 1]
\end{equation}


%-------------------------------------

\section{区块, 状态和交易} \label{ch:bst}

介绍完以太坊的基本概念后，我们来更细地讨论交易，区块，和状态的含义。


\subsection{世界状态（World State）} \label{ch:state}

世界状态 (\textit{状态})是一个地址（160位标识符）和账户状态（序列化成RLP的一种数据结构，参见附录\ref{app:rlp}）之间的映射表。 虽然世界状态并不存储在区块链中，但实现时会在一个经过改造的Merkle Patricia树(\textit{trie树}, 参见附录 \ref{app:trie})中维护这个映射表。Trie树需要一个简单的后台数据库来维护一个从字节数组（bytearray）到字节数组的映射表；我们称这个底层的数据库为状态数据库。这种做法有一些列优势：首先该结构的根节点在密码学上依赖于所有内部数据，因此根节点的散列值可被用作整个系统状态的一个安全的身份标识。其次，该结构是不可改变的，因此可以通过适当更改根节点的散列值召回任何之前的（散列值已知的）状态。因为我们在区块链上存储所有根节点的散列值，我们就可以毫不费力地回复到老状态。

账户状态包含以下四个域：

\begin{description}
\item[nonce] 一个标量，其值等于从该地址发送出的交易数，或者，对于有代码的账户，其值等于该账户生成的合约数量。对于在状态$\boldsymbol{\sigma}$中的地址$a$，该域可形式上表示为 $\boldsymbol{\sigma}[a]_n$。
\item[balance] 余额，是一个标量，其值等于该地址拥有的以太数量（以`伟'为单位）。形式上表示为$\boldsymbol{\sigma}[a]_b$。
\item[storageRoot] 存储根，它是存储账户内容的Merkle Patricia树的根节点的256位散列值。账户内容是一个从256位整数的键（key）的256位Keccak散列值到RLP编码的256位整数的值（value）的映射表，编码成一个Trie树形式。存储根形式上表示为 $\boldsymbol{\sigma}[a]_s$。
\item[codeHash] 代码散列，该账户EVM代码 --- 就是该地址一旦接收到消息调用就要执行的代码 -- 的散列值；由于账户代码是不可更改的，因此不像其它域，该域在账户生成后就不能被更改。所有代码片段都存储在状态数据库中，并且可用代码散列查询使用。代码散列形式上表示为 $\boldsymbol{\sigma}[a]_c$，因此代码如果表示为$\mathbf{b}$，就有$\texttt{\small KEC}(\mathbf{b}) = \boldsymbol{\sigma}[a]_c$。
\end{description}

Since I typically wish to refer not to the trie's root hash but to the underlying set of key/value pairs stored within, I define a convenient equivalence:
\begin{equation}
\texttt{\small TRIE}\big(L_I^*(\boldsymbol{\sigma}[a]_\mathbf{s})\big) \equiv \boldsymbol{\sigma}[a]_s
\end{equation}

The collapse function for the set of key/value pairs in the trie, $L_I^*$, is defined as the element-wise transformation of the base function $L_I$, given as:
\begin{equation}
L_I\big( (k, v) \big) \equiv \big(\texttt{\small KEC}(k), \texttt{\small RLP}(v)\big)
\end{equation}

where:
\begin{equation}
k \in \mathbb{B}_{32} \quad \wedge \quad v \in \mathbb{P}
\end{equation}

It shall be understood that $\boldsymbol{\sigma}[a]_\mathbf{s}$ is not a `physical' member of the account and does not contribute to its later serialisation.

If the \textbf{codeHash} field is the Keccak-256 hash of the empty string, i.e. $\boldsymbol{\sigma}[a]_c = \texttt{\small KEC}\big(()\big)$, then the node represents a simple account, sometimes referred to as a ``non-contract'' account.

Thus we may define a world-state collapse function $L_S$:
\begin{equation}
L_S(\boldsymbol{\sigma}) \equiv \{ p(a): \boldsymbol{\sigma}[a] \neq \varnothing \}
\end{equation}
where
\begin{equation}
p(a) \equiv  \big(\texttt{\small KEC}(a), \texttt{\small RLP}\big( (\boldsymbol{\sigma}[a]_n, \boldsymbol{\sigma}[a]_b, \boldsymbol{\sigma}[a]_s, \boldsymbol{\sigma}[a]_c) \big) \big)
\end{equation}

This function, $L_S$, is used alongside the trie function to provide a short identity (hash) of the world state. We assume:
\begin{equation}
\forall a: \boldsymbol{\sigma}[a] = \varnothing \; \vee \; (a \in \mathbb{B}_{20} \; \wedge \; v(\boldsymbol{\sigma}[a]))
\end{equation}
where $v$ is the account validity function:
\begin{equation}
\quad v(x) \equiv x_n \in \mathbb{P}_{256} \wedge x_b \in \mathbb{P}_{256} \wedge x_s \in \mathbb{B}_{32} \wedge x_c \in \mathbb{B}_{32}
\end{equation}

\subsection{Homestead} \label{ch:homestead}

A significant block number for compatibility with the public network is the block marking the transition between the {\it Frontier} and {\it Homestead} phases of the platform, which we denote with the symbol \firsthomesteadblock, defined thus
\begin{equation}
\firsthomesteadblock \equiv 1,\! 150,\! 000
\end{equation}
The protocol was upgraded at this block, so this symbol appears in some equations to account for the changes.

\subsection{The Transaction} \label{ch:transaction}

A transaction (formally, $T$) is a single cryptographically-signed instruction constructed by an actor externally to the scope of Ethereum. While is assumed that the ultimate external actor will be human in nature, software tools will be used in its construction and dissemination\footnote{Notably, such `tools' could ultimately become so causally removed from their human-based initiation---or humans may become so causally-neutral---that there could be a point at which they rightly be considered autonomous agents. \eg contracts may offer bounties to humans for being sent transactions to initiate their execution.}. There are two types of transactions: those which result in message calls and those which result in the creation of new accounts with associated code (known informally as `contract creation'). Both types specify a number of common fields:

\begin{description}
\item[nonce] A scalar value equal to the number of transactions sent by the sender; formally $T_n$.
\item[gasPrice] A scalar value equal to the number of Wei to be paid per unit of \textit{gas} for all computation costs incurred as a result of the execution of this transaction; formally $T_p$.
\item[gasLimit] A scalar value equal to the maximum amount of gas that should be used in executing this transaction. This is paid up-front, before any computation is done and may not be increased later; formally $T_g$.
\item[to] The 160-bit address of the message call's recipient or, for a contract creation transaction, $\varnothing$, used here to denote the only member of $\mathbb{B}_0$ ; formally $T_t$.
\item[value] A scalar value equal to the number of Wei to be transferred to the message call's recipient or, in the case of contract creation, as an endowment to the newly created account; formally $T_v$.
\item[v, r, s] Values corresponding to the signature of the transaction and used to determine the sender of the transaction; formally $T_w$, $T_r$ and $T_s$. This is expanded in Appendix \ref{app:signing}.
\end{description}

Additionally, a contract creation transaction contains:

\begin{description}
\item[init] An unlimited size byte array specifying the EVM-code for the account initialisation procedure, formally $T_\mathbf{i}$.
\end{description}

\textbf{init} is an EVM-code fragment; it returns the \textbf{body}, a second fragment of code that executes each time the account receives a message call (either through a transaction or due to the internal execution of code). \textbf{init} is executed only once at account creation and gets discarded immediately thereafter.

In contrast, a message call transaction contains:

\begin{description}
\item[data] An unlimited size byte array specifying the input data of the message call, formally $T_\mathbf{d}$.
\end{description}

Appendix \ref{app:signing} specifies the function, $S$, which maps transactions to the sender, and happens through the ECDSA of the SECP-256k1 curve, using the hash of the transaction (excepting the latter three signature fields) as the datum to sign. For the present we simply assert that the sender of a given transaction $T$ can be represented with $S(T)$.

\begin{equation}
L_T(T) \equiv \begin{cases}
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{i}, T_w, T_r, T_s) & \text{if} \; T_t = \varnothing\\
(T_n, T_p, T_g, T_t, T_v, T_\mathbf{d}, T_w, T_r, T_s) & \text{otherwise} 
\end{cases}
\end{equation}

Here, we assume all components are interpreted by the RLP as integer values, with the exception of the arbitrary length byte arrays $T_\mathbf{i}$ and $T_\mathbf{d}$.
\begin{equation}
\begin{array}[t]{lclclc}
T_n \in \mathbb{P}_{256} & \wedge & T_v \in \mathbb{P}_{256} & \wedge & T_p \in \mathbb{P}_{256} & \wedge \\
T_g \in \mathbb{P}_{256} & \wedge & T_w \in \mathbb{P}_5 & \wedge & T_r \in \mathbb{P}_{256} & \wedge \\
T_s \in \mathbb{P}_{256} & \wedge & T_\mathbf{d} \in \mathbb{B} & \wedge & T_\mathbf{i} \in \mathbb{B}
\end{array}
\end{equation}
where
\begin{equation}
\mathbb{P}_n = \{ P: P \in \mathbb{P} \wedge P < 2^n \}
\end{equation}

The address hash $T_\mathbf{t}$ is slightly different: it is either a 20-byte address hash or, in the case of being a contract-creation transaction (and thus formally equal to $\varnothing$), it is the RLP empty byte-series and thus the member of $\mathbb{B}_0$:
\begin{equation}
T_t \in \begin{cases} \mathbb{B}_{20} & \text{if} \quad T_t \neq \varnothing \\
\mathbb{B}_{0} & \text{otherwise}\end{cases}
\end{equation}

\subsection{The Block} \label{ch:block}

The block in Ethereum is the collection of relevant pieces of information (known as the block \textit{header}), $H$, together with information corresponding to the comprised transactions, $\mathbf{T}$, and a set of other block headers $\mathbf{U}$ that are known to have a parent equal to the present block's parent's parent (such blocks are known as \textit{ommers}\footnote{\textit{ommer} is the most prevalent (not saying much) gender-neutral term to mean ``sibling of parent''; see \url{http://nonbinary.org/wiki/Gender_neutral_language#Family_Terms}}). The block header contains several pieces of information:

%\textit{TODO: Introduce logs}

\begin{description}
\item[parentHash] The Keccak 256-bit hash of the parent block's header, in its entirety; formally $H_p$.
\item[ommersHash] The Keccak 256-bit hash of the ommers list portion of this block; formally $H_o$.
\item[beneficiary] The 160-bit address to which all fees collected from the successful mining of this block be transferred; formally $H_c$.
\item[stateRoot] The Keccak 256-bit hash of the root node of the state trie, after all transactions are executed and finalisations applied; formally $H_r$.
\item[transactionsRoot] The Keccak 256-bit hash of the root node of the trie structure populated with each transaction in the transactions list portion of the block; formally $H_t$.
\item[receiptsRoot] The Keccak 256-bit hash of the root node of the trie structure populated with the receipts of each transaction in the transactions list portion of the block; formally $H_e$.
\item[logsBloom] The Bloom filter composed from indexable information (logger address and log topics) contained in each log entry from the receipt of each transaction in the transactions list; formally $H_b$.
\item[difficulty] A scalar value corresponding to the difficulty level of this block. This can be calculated from the previous block's difficulty level and the timestamp; formally $H_d$.
\item[number] A scalar value equal to the number of ancestor blocks. The genesis block has a number of zero; formally $H_i$.
\item[gasLimit] A scalar value equal to the current limit of gas expenditure per block; formally $H_l$.
\item[gasUsed] A scalar value equal to the total gas used in transactions in this block; formally $H_g$.
\item[timestamp] A scalar value equal to the reasonable output of Unix's time() at this block's inception; formally $H_s$.
\item[extraData] An arbitrary byte array containing data relevant to this block. This must be 32 bytes or fewer; formally $H_x$.
\item[mixHash] A 256-bit hash which proves combined with the nonce that a sufficient amount of computation has been carried out on this block; formally $H_m$.
\item[nonce] A 64-bit hash which proves combined with the mix-hash that a sufficient amount of computation has been carried out on this block; formally $H_n$.
\end{description}

The other two components in the block are simply a list of ommer block headers (of the same format as above) and a series of the transactions. Formally, we can refer to a block $B$:
\begin{equation}
B \equiv (B_H, B_\mathbf{T}, B_\mathbf{U})
\end{equation}

\subsubsection{Transaction Receipt}

In order to encode information about a transaction concerning which it may be useful to form a zero-knowledge proof, or index and search, we encode a receipt of each transaction containing certain information from concerning its execution. Each receipt, denoted $B_\mathbf{R}[i]$ for the $i$th transaction) is placed in an index-keyed trie and the root recorded in the header as $H_e$.

The transaction receipt is a tuple of four items comprising the post-transaction state, $R_{\boldsymbol{\sigma}}$, the cumulative gas used in the block containing the transaction receipt as of immediately after the transaction has happened, $R_u$, the set of logs created through execution of the transaction, $R_\mathbf{l}$ and the Bloom filter composed from information in those logs, $R_b$:
\begin{equation}
R \equiv (R_{\boldsymbol{\sigma}}, R_u, R_b, R_\mathbf{l})
\end{equation}

The function $L_R$ trivially prepares a transaction receipt for being transformed into an RLP-serialised byte array:
\begin{equation}
L_R(R) \equiv (\mathtt{\small TRIE}(L_S(R_{\boldsymbol{\sigma}})), R_u, R_b, R_\mathbf{l})
\end{equation}
thus the post-transaction state, $R_{\boldsymbol{\sigma}}$ is encoded into a trie structure, the root of which forms the first item.

We assert $R_u$, the cumulative gas used is a positive integer and that the logs Bloom, $R_b$, is a hash of size 2048 bits (256 bytes):
\begin{equation}
R_u \in \mathbb{P} \quad \wedge \quad R_b \in \mathbb{B}_{256}
\end{equation}

%Notably $B_\mathbf{T}$ does not get serialised into the block by the block preparation function $L_B$; it is merely a convenience equivalence.

The log entries, $R_\mathbf{l}$, is a series of log entries, termed, for example, $(O_0, O_1, ...)$. A log entry, $O$, is a tuple of a logger's address, $O_a$, a series of 32-bytes log topics, $O_\mathbf{t}$ and some number of bytes of data, $O_\mathbf{d}$:
\begin{equation}
O \equiv (O_a, ({O_\mathbf{t}}_0, {O_\mathbf{t}}_1, ...), O_\mathbf{d})
\end{equation}
\begin{equation}
O_a \in \mathbb{B}_{20} \quad \wedge \quad \forall_{t \in O_\mathbf{t}}: t \in \mathbb{B}_{32} \quad \wedge \quad O_\mathbf{d} \in \mathbb{B}
\end{equation}

We define the Bloom filter function, $M$, to reduce a log entry include a single 256-byte hash:
\begin{equation}
M(O) \equiv \bigvee_{t \in \{O_a\} \cup O_\mathbf{t}} \big( M_{3:2048}(t) \big)
\end{equation}

where $M_{3:2048}$ is a specialised Bloom filter that sets three bits out of 2048, given an arbitrary byte series. It does this through taking the low-order 11 bits of each of the first three pairs of bytes in a Keccak-256 hash of the byte series. Formally:
\begin{eqnarray}
M_{3:2048}(\mathbf{x}: \mathbf{x} \in \mathbb{B}) & \equiv & \mathbf{y}: \mathbf{y} \in \mathbb{B}_{256} \quad \text{where:}\\
\mathbf{y} & = & (0, 0, ..., 0) \quad \text{except:}\\
\forall_{i \in \{0, 2, 4\}}&:& \mathcal{B}_{m(\mathbf{x}, i)}(\mathbf{y}) = 1\\
m(\mathbf{x}, i) &\equiv& \mathtt{\tiny KEC}(\mathbf{x})[i, i + 1] \bmod 2048
\end{eqnarray}

where $\mathcal{B}$ is the bit reference function such that $\mathcal{B}_j(\mathbf{x})$ equals the bit of index $j$ (indexed from 0) in the byte array $\mathbf{x}$.

\subsubsection{Holistic Validity}

We can assert a block's validity if and only if it satisfies several conditions: it must be internally consistent with the ommer and transaction block hashes and the given transactions $B_\mathbf{T}$ (as specified in sec \ref{ch:finalisation}), when executed in order on the base state $\boldsymbol{\sigma}$ (derived from the final state of the parent block), result in a new state of the identity $H_r$:
\begin{equation}
\begin{array}[t]{lclc}
H_r &\equiv& \mathtt{\small TRIE}(L_S(\Pi(\boldsymbol{\sigma}, B))) & \wedge \\
H_o &\equiv& \mathtt{\small KEC}(\mathtt{\small RLP}(L_H^*(B_\mathbf{U}))) & \wedge \\
H_t &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{T} \rVert, i \in \mathbb{P}: p(i, L_T(B_\mathbf{T}[i]))\}) & \wedge \\
H_e &\equiv& \mathtt{\small TRIE}(\{\forall i < \lVert B_\mathbf{R} \rVert, i \in \mathbb{P}: p(i, L_R(B_\mathbf{R}[i]))\}) & \wedge \\
H_b &\equiv& \bigvee_{\mathbf{r} \in B_\mathbf{R}} \big( \mathbf{r}_b \big)
\end{array}
\end{equation}

where $p(k, v)$ is simply the pairwise RLP transformation, in this case, the first being the index of the transaction in the block and the second being the transaction receipt:
\begin{equation}
p(k, v) \equiv \big( \mathtt{\small RLP}(k), \mathtt{\small RLP}(v) \big)
\end{equation}

Furthermore:
\begin{equation}
\mathtt{\small TRIE}(L_S(\boldsymbol{\sigma})) = {P(B_H)_H}_r
\end{equation}

Thus $\texttt{\small TRIE}(L_S(\boldsymbol{\sigma}))$ is the root node hash of the Merkle Patricia tree structure containing the key-value pairs of the state $\boldsymbol{\sigma}$ with values encoded using RLP, and $P(B_H)$ is the parent block of $B$, defined directly.

The values stemming from the computation of transactions, specifically the transaction receipts, $B_\mathbf{R}$, and that defined through the transactions state-accumulation function, $\Pi$, are formalised later in section \ref{sec:statenoncevalidation}.

\subsubsection{Serialisation}

The function $L_B$ and $L_H$ are the preparation functions for a block and block header respectively. Much like the transaction receipt preparation function $L_R$, we assert the types and order of the structure for when the RLP transformation is required:
\begin{eqnarray}
\quad L_H(H) & \equiv & (\begin{array}[t]{l}H_p, H_o, H_c, H_r, H_t, H_e, H_b, H_d,\\ H_i, H_l, H_g, H_s, H_x, H_m, H_n \; )\end{array} \\
\quad L_B(B) & \equiv & \big( L_H(B_H), L_T^*(B_\mathbf{T}), L_H^*(B_\mathbf{U}) \big)
\end{eqnarray}

With $L_T^*$ and $L_H^*$ being element-wise sequence transformations, thus:
\begin{equation}
f^*\big( (x_0, x_1, ...) \big) \equiv \big( f(x_0), f(x_1), ... \big) \quad \text{for any function} \; f
\end{equation}

The component types are defined thus:
\begin{equation}
\begin{array}[t]{lclclcl}
H_p \in \mathbb{B}_{32} & \wedge & H_o \in \mathbb{B}_{32} & \wedge & H_c \in \mathbb{B}_{20} & \wedge \\
H_r \in \mathbb{B}_{32} & \wedge & H_t \in \mathbb{B}_{32} & \wedge & H_e \in \mathbb{B}_{32} & \wedge \\
H_b \in \mathbb{B}_{256} & \wedge & H_d \in \mathbb{P} & \wedge & H_i \in \mathbb{P} & \wedge \\
H_l \in \mathbb{P} & \wedge & H_g \in \mathbb{P} & \wedge & H_s \in \mathbb{P}_{256} & \wedge \\
H_x \in \mathbb{B} & \wedge & H_m \in \mathbb{B}_{32} & \wedge & H_n \in \mathbb{B}_{8}
\end{array}
\end{equation}

where
\begin{equation}
\mathbb{B}_n = \{ B: B \in \mathbb{B} \wedge \lVert B \rVert = n \}
\end{equation}

We now have a rigorous specification for the construction of a formal block structure. The RLP function $\texttt{\small RLP}$ (see Appendix \ref{app:rlp}) provides the canonical method for transforming this structure into a sequence of bytes ready for transmission over the wire or storage locally.

\subsubsection{Block Header Validity}

We define $P(B_H)$ to be the parent block of $B$, formally:
\begin{equation}
P(H) \equiv B': \mathtt{\tiny KEC}(\mathtt{\tiny RLP}(B'_H)) = H_p
\end{equation}

The block number is the parent's block number incremented by one:
\begin{equation}
H_i \equiv {{P(H)_H}_i} + 1
\end{equation}

\newcommand{\mindifficulty}{D_0}
\newcommand{\frontiermod}{\ensuremath{\varsigma_1}}
\newcommand{\homesteadmod}{\ensuremath{\varsigma_2}}
\newcommand{\expdiffsymb}{\ensuremath{\epsilon}}
\newcommand{\diffadjustment}{x}

The canonical difficulty of a block of header $H$ is defined as $D(H)$:
\begin{equation}
D(H) \equiv \begin{dcases}
\mindifficulty & \text{if} \quad H_i = 0\\
\text{max}\!\left(\mindifficulty, {P(H)_H}_d + \diffadjustment\times\frontiermod + \expdiffsymb \right) & \text{if} \quad H_i<\firsthomesteadblock\\
\text{max}\!\left(\mindifficulty, {P(H)_H}_d + \diffadjustment\times\homesteadmod + \expdiffsymb \right) & \text{otherwise}\\
\end{dcases}
\end{equation}
where:
\begin{equation}
\mindifficulty \equiv 131072
\end{equation}
\begin{equation}
\diffadjustment \equiv \left\lfloor\frac{{P(H)_H}_d}{2048}\right\rfloor
\end{equation}
\begin{equation}
\frontiermod \equiv \begin{cases}
1 & \text{if} \quad H_s < {P(H)_H}_s + 13 \\
-1 & \text{otherwise} \\
\end{cases}
\end{equation}
\begin{equation}
\homesteadmod \equiv \text{max}\left( 1 - \left\lfloor\frac{H_s - {P(H)_H}_s}{10}\right\rfloor, -99 \right)
\end{equation}
\begin{equation}
\expdiffsymb \equiv \left\lfloor 2^{ \left\lfloor H_i \div 100000 \right\rfloor - 2 } \right\rfloor
\end{equation}

The canonical gas limit $H_l$ of a block of header $H$ must fulfil the relation:
\begin{eqnarray}
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor \quad \wedge \\
& & H_l \geqslant 125000
\end{eqnarray}

$H_s$ is the timestamp of block $H$ and must fulfil the relation:
\begin{equation}
H_s > {P(H)_H}_s
\end{equation}

This mechanism enforces a homeostasis in terms of the time between blocks; a smaller period between the last two blocks results in an increase in the difficulty level and thus additional computation required, lengthening the likely next period. Conversely, if the period is too large, the difficulty, and expected time to the next block, is reduced.

The nonce, $H_n$, must satisfy the relations:
\begin{equation}
n \leqslant \frac{2^{256}}{H_d} \quad \wedge \quad m = H_m
\end{equation}
with $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$.

Where $H_{\hcancel{n}}$ is the new block's header $H$, but \textit{without} the nonce and mix-hash components, $\mathbf{d}$ being the current DAG, a large data set needed to compute the mix-hash, and $\mathtt{PoW}$ is the proof-of-work function (see section \ref{ch:pow}): this evaluates to an array with the first item being the mix-hash, to proof that a correct DAG has been used, and the second item being a pseudo-random number cryptographically dependent on $H$ and $\mathbf{d}$. Given an approximately uniform distribution in the range $[0, 2^{64})$, the expected time to find a solution is proportional to the difficulty, $H_d$.

This is the foundation of the security of the blockchain and is the fundamental reason why a malicious node cannot propagate newly created blocks that would otherwise overwrite (``rewrite'') history. Because the nonce must satisfy this requirement, and because its satisfaction depends on the contents of the block and in turn its composed transactions, creating new, valid, blocks is difficult and, over time, requires approximately the total compute power of the trustworthy portion of the mining peers.

Thus we are able to define the block header validity function $V(H)$:
\begin{eqnarray}
V(H) & \equiv &  n \leqslant \frac{2^{256}}{H_d} \wedge m = H_m \quad \wedge \\
& & H_d = D(H) \quad \wedge \\
& & H_g \le H_l  \quad \wedge \\
& & H_l < {P(H)_H}_l + \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l > {P(H)_H}_l - \left\lfloor\frac{{P(H)_H}_l}{1024}\right\rfloor  \quad \wedge \\
& & H_l \geqslant 125000  \quad \wedge \\
& & H_s > {P(H)_H}_s \quad \wedge \\
& & H_i = {P(H)_H}_i +1 \quad \wedge \\
& & \lVert H_x \rVert \le 32
\end{eqnarray}
where $(n, m) = \mathtt{PoW}(H_{\hcancel{n}}, H_n, \mathbf{d})$

Noting additionally that \textbf{extraData} must be at most 32 bytes.

%-------------------------------------

\end{multicols}
\end{document}